---
layout: post

toc: true

title: "[AI 실전] 프롬프트 설계 - Temperature, Persona, 함수 호출 관점"

date: 2025-12-13 10:50:00 +0900

comments: true

categories: [AI, Prompt Engineering]

tags: [AI, Prompt, Function Design]


---

### 1. 프롬프트 = 함수 설계

프롬프트는 함수 호출과 동일함. 모호한 입력은 Garbage Output을 생성함.

#### 함수 시그니처 비교

```java
// Bad: 타입 불명확, 제약조건 없음
Object generate(String prompt);  // Return type: Object (Unknown)

// Good: 명확한 타입과 제약조건
ResponseDTO generate(PromptRequest request);
// - PromptRequest: Persona, Context, Task, OutputFormat 포함
// - ResponseDTO: 구조화된 반환 타입
```

#### 실제 비교

```java
// ❌ Bad: 파라미터 불충분
String result = llm.generate("코드 짜줘");
// 문제점:
// - 무슨 코드? (Task 불명확)
// - 어떤 언어? (Context 없음)
// - 무엇을 위한? (Persona/Context 없음)
// - 어떤 형식? (Output Format 없음)

// ✅ Good: 명확한 파라미터
String result = llm.generate(
    """
    [Persona] 너는 10년차 Spring Boot 전문가야.
    [Context] Spring Boot 3.0, Java 17, MySQL 8.0
    [Task] User 엔티티에 대한 REST API Controller 작성
    [Output] Java 코드 블록, Swagger 어노테이션 포함
    """
);
```

------

### 2. Temperature 파라미터 (0.0 ~ 2.0)

다음 토큰 선택 시 확률 분포의 '평탄화' 정도를 조절하는 파라미터.

#### Temperature 동작 원리

```java
// Temperature = 확률 분포 조절
public class TemperatureControl {
    
    // Temperature 0.0: 가장 높은 확률의 토큰만 선택 (Deterministic)
    public Token selectNextToken0(Map<Token, Double> probabilities) {
        return probabilities.entrySet().stream()
            .max(Map.Entry.comparingByValue())
            .get().getKey();  // 항상 동일한 결과
    }
    
    // Temperature 1.0: 확률 분포에 따라 샘플링 (Stochastic)
    public Token selectNextToken1(Map<Token, Double> probabilities) {
        // 확률 분포를 평탄화하여 다양한 토큰 선택 가능
        return weightedRandomSample(probabilities, temperature=1.0);
    }
    
    // Temperature 2.0: 극도로 평탄화 (매우 창의적, 부정확할 수 있음)
    public Token selectNextToken2(Map<Token, Double> probabilities) {
        return weightedRandomSample(probabilities, temperature=2.0);
    }
}
```

#### Temperature 값별 권장 사용처

| Temperature | 범위 | 특징 | 권장 사용처 | 비유 |
|------------|------|------|-----------|------|
| **0.0** | Deterministic | 항상 동일한 답변 | 코드 생성, 팩트 체크, JSON 파싱, 번역, 수학 문제 | `Collections.sort()` - 정해진 순서 |
| **0.1 ~ 0.3** | Low Randomness | 거의 동일, 약간의 변화 | 데이터 추출, 구조화된 응답, SQL 쿼리 | `HashMap` - 예측 가능 |
| **0.4 ~ 0.6** | Balanced | 적당한 다양성 | 개념 설명, 코드 리뷰, 문서 작성, 요약 | `new Random()` - 적당한 무작위성 |
| **0.7 ~ 1.0** | Creative | 다양한 표현 | 블로그 글쓰기, 아이디어 브레인스토밍, 네이밍 | `ThreadLocalRandom` - 창의적 |
| **1.1 ~ 2.0** | Highly Creative | 극도의 다양성, 부정확할 수 있음 | 창작, 소설, 실험적 시도 | `SecureRandom` - 극도의 변동성 |

#### Temperature 변화에 따른 답변 비교

**질문:** "Spring Boot의 장점을 3가지 말해줘"

**Temperature = 0.0 (Deterministic)**

```markdown
첫 번째 실행:
1. 자동 설정 (Auto Configuration)
2. 독립 실행형 애플리케이션
3. 강력한 생태계

두 번째 실행:
1. 자동 설정 (Auto Configuration)  ← 똑같음
2. 독립 실행형 애플리케이션
3. 강력한 생태계

세 번째 실행:
1. 자동 설정 (Auto Configuration)  ← 똑같음
2. 독립 실행형 애플리케이션
3. 강력한 생태계
```

**Temperature = 0.7 (Creative)**

```markdown
첫 번째 실행:
1. 빠른 개발 속도
2. 마이크로서비스 친화적
3. 방대한 커뮤니티

두 번째 실행:
1. 설정의 단순화
2. 내장 서버 지원
3. 프로덕션 준비 기능

세 번째 실행:
1. 의존성 관리 자동화
2. 개발자 경험 향상
3. 엔터프라이즈급 기능
```

**Temperature = 1.5 (Highly Creative)**

```markdown
첫 번째 실행:
1. 개발자 행복도 향상
2. 마법 같은 자동 설정
3. 세상에서 가장 쿨한 프레임워크

두 번째 실행:
1. Spring Boot는 커피처럼 개발자를 깨워줘요
2. XML 지옥에서의 탈출구
3. ...

→ 창의적이지만 부정확할 수 있음
```

#### 실전 Temperature 선택 가이드

```java
@Service
public class TemperatureSelector {
    
    /**
     * 작업 유형에 따른 Temperature 선택
     */
    public double selectTemperature(String taskType) {
        return switch (taskType) {
            // 정확성이 최우선 (코딩 질문 시 반드시 0에 가깝게)
            case "CODE_GENERATION" -> 0.0;      // 코드 생성
            case "TRANSLATION" -> 0.0;          // 번역
            case "MATH" -> 0.0;                 // 수학 문제
            case "DATA_EXTRACTION" -> 0.1;      // 데이터 추출
            case "JSON_PARSING" -> 0.0;         // JSON 파싱
            case "FACT_CHECK" -> 0.0;           // 팩트 체크
            
            // 균형 잡힌 작업
            case "EXPLANATION" -> 0.3;          // 개념 설명
            case "CODE_REVIEW" -> 0.3;          // 코드 리뷰
            case "REFACTORING" -> 0.5;          // 리팩토링 제안
            case "DOCUMENTATION" -> 0.5;        // 문서 작성
            case "SUMMARY" -> 0.4;              // 요약
            
            // 창의성이 필요한 작업
            case "BRAINSTORMING" -> 0.8;        // 아이디어 회의
            case "NAMING" -> 0.7;               // 네이밍
            case "BLOG_WRITING" -> 0.7;         // 블로그 글쓰기
            case "CREATIVE_WRITING" -> 1.0;      // 창작
            
            default -> 0.7; // 기본값
        };
    }
}
```

**핵심 규칙:** 코딩 질문 시엔 반드시 `0.0`에 가깝게 설정할 것.

------

### 3. System Prompt vs User Prompt

#### System Prompt = Global Config

전역 설정, 페르소나, 규칙을 정의. `Environment Variable` 또는 `application.yml`과 동일.

```java
// System Prompt = 전역 설정
public class SystemConfig {
    // application.yml
    public static final String SYSTEM_PROMPT = """
        당신은 10년차 Spring Boot 전문가입니다.
        - Clean Code 원칙을 준수합니다.
        - 모든 코드에 주석을 포함합니다.
        - 예외 처리를 반드시 포함합니다.
        """;
    
    // 모든 요청에 공통으로 적용됨
}
```

#### User Prompt = Runtime Input

실제 요청 내용. 함수의 파라미터와 동일.

```java
// User Prompt = 런타임 입력
String userPrompt = """
    Spring Boot에서 JWT 인증 필터를 구현해줘.
    SecurityConfig에 등록하는 방법도 포함해줘.
    """;
```

#### System vs User 비교

```java
@RestController
public class AIController {
    
    // System Prompt (한 번만 설정, 모든 요청에 적용)
    private static final String SYSTEM_PROMPT = """
        당신은 10년차 Java 백엔드 개발자입니다.
        - 실무 경험 기반의 답변을 제공합니다.
        - 코드 예시는 프로덕션 레벨로 작성합니다.
        - 각 단계를 명확히 설명합니다.
        """;
    
    @PostMapping("/ask")
    public String ask(@RequestBody String userQuestion) {
        // System Prompt + User Prompt 조합
        return openAI.chat(
            systemPrompt: SYSTEM_PROMPT,  // 전역 설정
            userPrompt: userQuestion,      // 실제 요청
            temperature: 0.3
        );
    }
}
```

#### 실전 예시

```markdown
[System Prompt] (전역 설정)
"""
당신은 10년차 Spring Security 전문가이며, 
OWASP Top 10 보안 취약점을 기준으로 코드를 리뷰합니다.
- 실무 경험 기반의 답변 제공
- 보안 취약점을 우선적으로 체크
- 각 취약점의 심각도를 명시
"""

[User Prompt] (실제 요청)
"""
다음 코드의 보안 취약점을 분석해줘:

@RestController
public class UserController {
    @GetMapping("/user/{id}")
    public User getUser(@PathVariable String id) {
        return userRepository.findById(id);
    }
}
"""

→ System Prompt의 페르소나와 규칙이 모든 답변에 적용됨
```

------

### 4. Persona 심화: 구체적 역할 부여

단순한 역할 부여는 효과가 제한적임. 구체적인 전문성과 기준을 명시해야 함.

#### Bad vs Good Persona 비교

**❌ Bad: 단순한 역할 부여**

```markdown
[Persona]
너는 개발자야.

→ 결과: 일반적인 개발자 관점의 답변
→ 문제: 전문 용어(Jargon)와 패턴 인출 확률 낮음
```

**✅ Good: 구체적인 전문성과 기준 명시**

```markdown
[Persona]
너는 10년차 Spring Security 전문가이며, 
OWASP Top 10 보안 취약점을 기준으로 코드를 리뷰한다.
- 실무에서 수많은 보안 이슈를 해결한 경험 보유
- OWASP Top 10, CWE Top 25 기준으로 취약점 분석
- 각 취약점의 CVSS 점수와 실무 영향도 평가
- 보안 패치 우선순위 제안

→ 결과: 전문 용어와 보안 패턴이 활성화됨 (Latent Space Activation)
→ 효과: OWASP, CWE, CVSS 등 전문 용어 사용, 보안 중심 답변
```

#### Persona 심화 예시

**예시 1: 보안 전문가**

```markdown
[Persona]
너는 10년차 보안 전문가이며, OWASP Top 10과 CWE Top 25를 기준으로 코드를 분석한다.
- 실무에서 SQL Injection, XSS, CSRF 등 취약점을 수백 건 해결한 경험
- 각 취약점의 CVSS 점수와 실무 영향도를 평가
- 보안 패치 우선순위를 제안
- OWASP ASVS (Application Security Verification Standard) 기준 준수

[질문]
다음 코드의 보안 취약점을 분석해줘:
...

→ 결과: OWASP, CWE, CVSS, ASVS 등 전문 용어 사용
→ 효과: 보안 중심의 깊이 있는 분석
```

**예시 2: 성능 최적화 전문가**

```markdown
[Persona]
너는 10년차 백엔드 성능 최적화 전문가이며, 
대용량 트래픽 처리 경험이 있다.
- JVM 튜닝, 쿼리 최적화, 캐싱 전략 전문
- APM (Application Performance Monitoring) 도구 활용 경험
- 성능 병목 지점을 프로파일링하여 정확히 진단
- 각 최적화 기법의 Trade-off를 명시

[질문]
다음 코드의 성능 이슈를 분석해줘:
...

→ 결과: JVM 튜닝, APM, 프로파일링 등 전문 용어 사용
→ 효과: 성능 중심의 구체적 분석
```

**예시 3: 아키텍처 설계 전문가**

```markdown
[Persona]
너는 10년차 백엔드 아키텍트이며, 
MSA 전환과 분산 시스템 설계 경험이 풍부하다.
- Domain-Driven Design (DDD) 원칙 적용
- Event-Driven Architecture (EDA) 설계 경험
- Saga 패턴, CQRS 패턴 실무 적용
- 각 아키텍처 패턴의 Trade-off와 적용 시나리오 명시

[질문]
모놀리식을 MSA로 전환하는 전략을 설계해줘:
...

→ 결과: DDD, EDA, Saga, CQRS 등 전문 용어 사용
→ 효과: 아키텍처 중심의 체계적 설계
```

#### Latent Space Activation

구체적인 Persona는 LLM의 Latent Space에서 관련 전문 용어와 패턴을 활성화함.

```java
// Persona = Latent Space Activation
public class PersonaActivation {
    
    // 단순 Persona
    String simplePersona = "너는 개발자야.";
    // → 활성화되는 용어: 일반적인 개발 용어
    
    // 구체적 Persona
    String specificPersona = """
        너는 10년차 Spring Security 전문가이며,
        OWASP Top 10 보안 취약점을 기준으로 코드를 리뷰한다.
        """;
    // → 활성화되는 용어:
    //   - OWASP, CWE, CVSS
    //   - SQL Injection, XSS, CSRF
    //   - Security Headers, CSP, HSTS
    //   - Authentication, Authorization
    //   - JWT, OAuth2, SAML
    // → 관련 패턴과 해결책이 자동으로 인출됨
}
```

------

### 5. 실전 프롬프트 설계 패턴

#### 패턴 1: System Prompt + User Prompt 조합

```java
@Service
public class PromptService {
    
    // System Prompt (전역 설정)
    private static final String SYSTEM_PROMPT = """
        당신은 10년차 Spring Security 전문가이며,
        OWASP Top 10 보안 취약점을 기준으로 코드를 리뷰합니다.
        
        [답변 규칙]
        - 각 취약점의 심각도를 명시 (Critical, High, Medium, Low)
        - CVSS 점수와 실무 영향도 평가
        - 구체적인 해결 방법과 코드 예시 제공
        - 보안 패치 우선순위 제안
        """;
    
    public String reviewCode(String code) {
        // User Prompt (실제 요청)
        String userPrompt = String.format("""
            다음 코드의 보안 취약점을 분석해주세요:
            
            ```java
            %s
            ```
            
            [분석 관점]
            1. OWASP Top 10 기준 취약점 체크
            2. 각 취약점의 심각도와 영향도
            3. 구체적인 해결 방법
            """, code);
        
        return openAI.chat(
            systemPrompt: SYSTEM_PROMPT,
            userPrompt: userPrompt,
            temperature: 0.3  // 코드 리뷰는 정확성 우선
        );
    }
}
```

#### 패턴 2: Temperature별 작업 분류

```java
@RestController
public class AIController {
    
    /**
     * 코드 생성 - Temperature 0.0 (정확성 최우선)
     */
    @PostMapping("/generate-code")
    public String generateCode(@RequestBody CodeRequest request) {
        String prompt = String.format("""
            다음 요구사항에 맞는 Java 코드를 생성해주세요:
            %s
            
            코드만 출력하고, 설명은 주석으로 작성하세요.
            """, request.getRequirements());
        
        return openAI.chat(
            prompt,
            temperature: 0.0  // 코딩 질문 시 반드시 0에 가깝게
        );
    }
    
    /**
     * 아이디어 브레인스토밍 - Temperature 0.8 (창의성)
     */
    @PostMapping("/brainstorm")
    public String brainstorm(@RequestBody String topic) {
        String prompt = String.format("""
            '%s'에 대한 새로운 아이디어를 10가지 제안해주세요.
            """, topic);
        
        return openAI.chat(
            prompt,
            temperature: 0.8  // 창의성 필요
        );
    }
    
    /**
     * 코드 리뷰 - Temperature 0.3 (균형)
     */
    @PostMapping("/code-review")
    public String reviewCode(@RequestBody String code) {
        String prompt = String.format("""
            다음 코드를 리뷰해주세요:
            ```java
            %s
            ```
            """, code);
        
        return openAI.chat(
            prompt,
            temperature: 0.3  // 균형
        );
    }
}
```

#### 패턴 3: 구체적 Persona 적용

```java
@Component
public class PersonaTemplates {
    
    /**
     * 보안 전문가 Persona (구체적)
     */
    public static final String SECURITY_EXPERT = """
        당신은 10년차 보안 전문가이며,
        OWASP Top 10과 CWE Top 25를 기준으로 코드를 분석합니다.
        
        [전문 분야]
        - 웹 애플리케이션 보안 (OWASP Top 10)
        - API 보안 (OWASP API Security Top 10)
        - 인증/인가 (OAuth2, JWT, SAML)
        - 암호화 (AES, RSA, 해시 함수)
        
        [분석 기준]
        - OWASP Top 10 (2021)
        - CWE Top 25
        - CVSS 점수 평가
        - 실무 영향도 분석
        
        [답변 형식]
        1. 발견된 취약점 (심각도별)
        2. 각 취약점의 CVSS 점수
        3. 실무 영향도 평가
        4. 구체적인 해결 방법
        5. 보안 패치 우선순위
        """;
    
    /**
     * 성능 최적화 전문가 Persona (구체적)
     */
    public static final String PERFORMANCE_EXPERT = """
        당신은 10년차 백엔드 성능 최적화 전문가이며,
        대용량 트래픽 처리 경험이 풍부합니다.
        
        [전문 분야]
        - JVM 튜닝 (GC, Heap, Metaspace)
        - 쿼리 최적화 (인덱스, 실행 계획)
        - 캐싱 전략 (Redis, Caffeine)
        - 비동기 처리 (CompletableFuture, Reactor)
        
        [분석 도구]
        - APM (New Relic, Datadog, Pinpoint)
        - 프로파일러 (JProfiler, VisualVM)
        - 쿼리 분석기 (EXPLAIN, Query Plan)
        
        [답변 형식]
        1. 성능 병목 지점 진단
        2. 프로파일링 결과 분석
        3. 구체적인 최적화 방법
        4. 각 방법의 Trade-off
        5. 예상 성능 개선 효과
        """;
}
```

------

### 6. Temperature + Persona 조합 예시

#### 예시 1: 코드 생성 (Temperature 0.0 + 구체적 Persona)

```markdown
[System Prompt]
당신은 10년차 Spring Security 전문가이며,
OWASP Top 10 보안 취약점을 기준으로 코드를 작성합니다.

[User Prompt]
JWT 기반 인증 필터를 구현해줘.
- 토큰 검증 로직 포함
- SecurityContext에 인증 정보 저장
- 예외 처리 포함

[Temperature] 0.0

→ 결과: 정확하고 보안을 고려한 코드 생성
→ 특징: 매번 동일한 답변, 보안 패턴 적용
```

#### 예시 2: 아이디어 브레인스토밍 (Temperature 0.8 + 일반 Persona)

```markdown
[System Prompt]
당신은 창의적인 백엔드 개발자입니다.

[User Prompt]
새로운 B2B SaaS 아이디어를 10가지 제안해줘.

[Temperature] 0.8

→ 결과: 다양한 창의적인 아이디어
→ 특징: 실행마다 다른 아이디어 제안
```

#### 예시 3: 코드 리뷰 (Temperature 0.3 + 구체적 Persona)

```markdown
[System Prompt]
당신은 10년차 보안 전문가이며,
OWASP Top 10을 기준으로 코드를 리뷰합니다.

[User Prompt]
다음 코드의 보안 취약점을 분석해줘:
...

[Temperature] 0.3

→ 결과: 보안 중심의 균형잡힌 리뷰
→ 특징: 적당한 다양성 + 전문성
```

------

### 7. 핵심 정리

#### Temperature 선택 규칙

1. **코딩 질문 시**: 반드시 `0.0`에 가깝게 설정
2. **팩트 체크**: `0.0`
3. **구조화된 응답**: `0.1 ~ 0.3`
4. **일반 설명**: `0.3 ~ 0.6`
5. **창의적 작업**: `0.7 ~ 1.0`

#### System Prompt vs User Prompt

- **System Prompt**: 전역 설정, 페르소나, 규칙 (Global Config)
- **User Prompt**: 실제 요청 내용 (Runtime Input)

#### Persona 설계 원칙

1. **구체적인 전문성 명시**: "10년차 Spring Security 전문가"
2. **기준과 원칙 명시**: "OWASP Top 10 기준으로"
3. **경험과 배경 명시**: "실무에서 수백 건 해결한 경험"
4. **답변 형식 명시**: "심각도별로 분류하여"

#### Latent Space Activation

구체적인 Persona는 관련 전문 용어와 패턴을 활성화하여 더 정확하고 전문적인 답변을 생성함.

------

> 참고 자료
> - OpenAI API Documentation: https://platform.openai.com/docs/api-reference/chat/create
> - Temperature Parameter Guide: https://platform.openai.com/docs/guides/text-generation
> - OWASP Top 10: https://owasp.org/www-project-top-ten/
> - CWE Top 25: https://cwe.mitre.org/top25/
